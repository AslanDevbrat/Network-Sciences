{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Questions 6"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Implementing the function without using built-in function"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "    This is a GraphEdge class\n",
    "    self.node denotes node from where the node is generating\n",
    "    self.distance is the weight for the edge"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "class GraphEdge(object):\n",
    "    def __init__(self, node, distance):\n",
    "        self.node = node\n",
    "        self.distance = distance"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "        I have used math built-in fuction just to give 'infinity' weight to the edge "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [],
   "source": [
    "import math\n",
    "class GraphNode(object):\n",
    "    def __init__(self, val):\n",
    "        self.value = val\n",
    "        self.edges = []\n",
    "\n",
    "    def add_child(self, node, distance):\n",
    "        self.edges.append(GraphEdge(node, distance))\n",
    "\n",
    "    def remove_child(self, del_node):\n",
    "        if del_node in self.edges:\n",
    "            self.edges.remove(del_node)\n",
    "\n",
    "class Graph(object):\n",
    "    def __init__(self, node_list):\n",
    "        self.nodes = node_list\n",
    "\n",
    "    def add_edge(self, node1, node2, distance):\n",
    "        if node1 in self.nodes and node2 in self.nodes:\n",
    "            node1.add_child(node2, distance)\n",
    "            node2.add_child(node1, distance)\n",
    "\n",
    "    def remove_edge(self, node1, node2):\n",
    "        if node1 in self.nodes and node2 in self.nodes:\n",
    "            node1.remove_child(node2)\n",
    "            node2.remove_child(node1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [],
   "source": [
    "node_u = GraphNode('U')\n",
    "node_d = GraphNode('D')\n",
    "node_a = GraphNode('A')\n",
    "node_c = GraphNode('C')\n",
    "node_i = GraphNode('I')\n",
    "node_t = GraphNode('T')\n",
    "node_y = GraphNode('Y')\n",
    "\n",
    "graph = Graph([node_u, node_d, node_a, node_c, node_i, node_t, node_y])\n",
    "graph.add_edge(node_u, node_a, 1)\n",
    "graph.add_edge(node_u, node_c, 1)\n",
    "graph.add_edge(node_u, node_d, 1)\n",
    "graph.add_edge(node_d, node_u, 1)\n",
    "graph.add_edge(node_d, node_c, 1)\n",
    "graph.add_edge(node_a, node_u, 1)\n",
    "graph.add_edge(node_a, node_i, 1)\n",
    "graph.add_edge(node_c, node_d, 1)\n",
    "graph.add_edge(node_c, node_u, 1)\n",
    "graph.add_edge(node_c, node_i, 1)\n",
    "graph.add_edge(node_c, node_t, 1)\n",
    "graph.add_edge(node_i, node_a, 1)\n",
    "graph.add_edge(node_i, node_c, 1)\n",
    "graph.add_edge(node_i, node_y, 1)\n",
    "graph.add_edge(node_t, node_c, 1)\n",
    "graph.add_edge(node_t, node_y, 1)\n",
    "graph.add_edge(node_y, node_i, 1)\n",
    "graph.add_edge(node_y, node_t, 1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Logic\n",
    "\n",
    "I have used dijkstra alogrithm to find smallest distance between two node.\n",
    "Dijkstra uses edges weight to find the cheapest path. SO I have given weight of \"1\"\n",
    "to each edge. So weighted graph with all edgeweight of 1 is same as undirected\n",
    "unweighted graph"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 87,
   "metadata": {},
   "outputs": [],
   "source": [
    "def dijkstra(start_node, end_node):\n",
    "    distance_dict = {node: math.inf for node in graph.nodes}\n",
    "    shortest_path_to_node = {}\n",
    "\n",
    "    distance_dict[start_node] = 0\n",
    "    while distance_dict:\n",
    "        # Pop the shorest path \n",
    "        current_node, node_distance = sorted(distance_dict.items(), key=lambda x: x[1])[0]\n",
    "        shortest_path_to_node[current_node] = distance_dict.pop(current_node)\n",
    "\n",
    "        for edge in current_node.edges:\n",
    "            if edge.node in distance_dict:\n",
    "                new_node_distance = node_distance + edge.distance\n",
    "                if distance_dict[edge.node] > new_node_distance:\n",
    "                    distance_dict[edge.node] = new_node_distance\n",
    "    \n",
    "    return shortest_path_to_node[end_node]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 75,
   "metadata": {},
   "outputs": [],
   "source": [
    "def using_dijkstra():\n",
    "    nodes = [node_a, node_c, node_d, node_i, node_t, node_u, node_y]\n",
    "    closeness_centrality_dict = dict()\n",
    "    for node1 in nodes:\n",
    "        d=0\n",
    "        for node2 in nodes:\n",
    "            if node1 != node2:\n",
    "                #print('Shortest Distance from {} to {} is {}'.format(node1.value, node2.value, dijkstra(node1, node2)))\n",
    "                d+=1/dijkstra(node1, node2)\n",
    "\n",
    "        closeness_centrality_dict[node1.value] = (1/(len(nodes)-1))*d\n",
    "\n",
    "        #print('d=',d)\n",
    "    #print(closeness_centrality_dict)\n",
    "    return closeness_centrality_dict\n",
    "    \n",
    "        "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Creating the graph using built-in Library"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 88,
   "metadata": {},
   "outputs": [],
   "source": [
    "import networkx as nx\n",
    "g = nx.Graph()\n",
    "g.add_edge('U','D')\n",
    "g.add_edge('U','C')\n",
    "g.add_edge('U','A')\n",
    "g.add_edge('D','C')\n",
    "g.add_edge('U','D')\n",
    "g.add_edge('A','I')\n",
    "g.add_edge('C','I')\n",
    "g.add_edge('C','T')\n",
    "g.add_edge('T','Y')\n",
    "g.add_edge('I','Y')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This fuction return a dictionary of node with their closeness centrality"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 89,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "def using_built_in_library(graph):\n",
    "    return nx.closeness_centrality(graph)\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Sorting the node based on the centrality, if their is a tie then sorting those elements based on node name alphabatically"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 101,
   "metadata": {},
   "outputs": [],
   "source": [
    "sorted_node_by_dij = sorted(using_dijkstra().items(), key=lambda x: (x[1],x[0]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 102,
   "metadata": {},
   "outputs": [],
   "source": [
    "sorted_builtin_node = sorted(using_built_in_library(g).items(), key=lambda x: (x[1],x[0]))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Final Testing\n",
    "### Checking if the list generate by user-defined function and built-in function are same or not"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 113,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Test Pass \n",
      "\n",
      "Closeness Centrality generated by user-defined Function\n",
      "\n",
      "Node Y has closeness centrality 0.611111111111111\n",
      "Node A has closeness centrality 0.6388888888888888\n",
      "Node D has closeness centrality 0.6388888888888888\n",
      "Node T has closeness centrality 0.6388888888888888\n",
      "Node U has closeness centrality 0.7222222222222221\n",
      "Node I has closeness centrality 0.75\n",
      "Node C has closeness centrality 0.8333333333333333\n",
      "----------------------------------------------------------------\n",
      "\n",
      "Closeness Centrality generated by built-in Function\n",
      "\n",
      "Node Y has closeness centrality 0.5\n",
      "Node A has closeness centrality 0.5454545454545454\n",
      "Node D has closeness centrality 0.5454545454545454\n",
      "Node T has closeness centrality 0.5454545454545454\n",
      "Node U has closeness centrality 0.6\n",
      "Node I has closeness centrality 0.6666666666666666\n",
      "Node C has closeness centrality 0.75\n"
     ]
    }
   ],
   "source": [
    "def print_node_with_closeness_centrality(node_list,node_dict):\n",
    "    for node in node_list:\n",
    "        print(f\"Node {node} has closeness centrality {node_dict[node]}\")\n",
    "sorted_node_list_1 = [i[0] for i in sorted_node_by_dij]\n",
    "sorted_node_list_2 = [i[0] for i in sorted_x]\n",
    "if sorted_node_list_1==sorted_node_list_2:\n",
    "    print('Test Pass ') \n",
    "    print('')\n",
    "    print('Closeness Centrality generated by user-defined Function')\n",
    "    print('')\n",
    "    print_node_with_closeness_centrality(sorted_node_list_1,dict(sorted_node_by_dij))\n",
    "    print('----------------------------------------------------------------')\n",
    "    print('')\n",
    "    print('Closeness Centrality generated by built-in Function')\n",
    "    print('')\n",
    "    print_node_with_closeness_centrality(sorted_node_list_2,dict(sorted_builtin_node))\n",
    "    \n",
    "else:\n",
    "    print('Test fail')\n",
    "    print('')\n",
    "    print('Closeness Centrality generated by user-defined Function')\n",
    "    print('')\n",
    "    print_node_with_closeness_centrality(sorted_node_list_1,dict(sorted_node_by_dij))\n",
    "    print('----------------------------------------------------------------')\n",
    "    print('')\n",
    "    print('Closeness Centrality generated by built-in Function')\n",
    "    print('')\n",
    "    print_node_with_closeness_centrality(sorted_node_list_2,dict(sorted_builtin_node))\n",
    "    \n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Buiding the second graph"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "node_d = GraphNode('D')\n",
    "node_e = GraphNode('E')\n",
    "node_v = GraphNode('V')\n",
    "node_a = GraphNode('A')\n",
    "\n",
    "graph2 = Graph([node_d, node_e, node_v, node_a])\n",
    "graph2.add_edge()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
